Object subclass: #AMB	instanceVariableNames: 'failContinuation'	classVariableNames: ''	poolDictionaries: ''	category: 'AMB'!!AMB commentStamp: 'jjddpp 11/24/2015 10:47' prior: 0!this is the "ambigous", "nondeterminist", "angelic" operator aka amb... more seriously described as a declarative control flow statement able to enumerate over finite domains all values that make a program terminate. it uses continuations to walk the tree of possible tuples, backtracking when the program fails. the amazing thing is the simplicity of the code: four short or very short methods on the instance side, the class side methods only providing syntactic sugar.and it can do incredible things such as:AMB assert: [:string :n :char | (string occurrencesOf: char) = n]	over: #('maman' 'barbapapa' 'guiliguili' 'arthur' 'chtulu')	and: #(2 4 1)	and: #($m $b $a $i $u)see AMBTest for more magic.!!AMB methodsFor: 'simple' stamp: 'spfa 11/18/2009 18:07'!boolean	^ self try: {true . false}! !!AMB methodsFor: 'simple' stamp: 'spfa 11/18/2009 18:07'!falseOrtrue	^ self try: {false . true}! !!AMB methodsFor: 'simple' stamp: 'spfa 11/18/2009 18:07'!deny: aBoolean	aBoolean ifTrue: [self next]! !!AMB methodsFor: 'simple' stamp: 'spfa 11/18/2009 18:07'!trueOrFalse	^ self try: {true . false}! !!AMB methodsFor: 'simple' stamp: 'spfa 11/18/2009 18:07'!assert: aBoolean	aBoolean ifFalse: [self next]! !!AMB methodsFor: 'core' stamp: 'spfa 11/18/2009 18:07'!initialize	failContinuation := [AMBError new signal: 'AMB tree exhausted']! !!AMB methodsFor: 'core' stamp: 'spfa 11/18/2009 18:07'!next	^ self try: #()! !!AMB methodsFor: 'core' stamp: 'jjddpp 11/24/2015 11:16'!try: aCollection	| prev | 	prev := failContinuation.	^ Continuation callcc: [:c | 		aCollection do: [:alt | 			Continuation callcc: [:calt | 				failContinuation := [ failContinuation := prev.     calt value: #fail ].				c value: alt]].	     ^ prev value]! !!AMB methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/24/2015 11:00'!repeat: aBlock	| prev | 	prev := failContinuation.	^ Continuation currentDo: [:c |		[			Continuation currentDo: [:cin |				failContinuation := [										failContinuation := prev. 										cin value: #fail									].				c value: aBlock value]		] repeat]! !!AMB methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/24/2015 11:00'!iterate: aBlock from: seed	| prev g | 	prev := failContinuation.	g := seed.	^ Continuation currentDo: [:c |		[			Continuation currentDo: [:cin |				failContinuation := [										failContinuation := prev. 										cin value: #fail									].				c value: (g := aBlock value: g)]		] repeat]! !!AMB methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/24/2015 11:00'!do: aBlock or: bBlock	| prev | 	prev := failContinuation.	^ Continuation currentDo: [:c |		Continuation currentDo: [:cin |			failContinuation := [									failContinuation := prev. 									cin value: #fail								].			c value: aBlock value].		Continuation currentDo: [:cin |			failContinuation := [									failContinuation := prev. 									cin value: #fail								].			c value: bBlock value].		^ prev value]! !!AMB methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/24/2015 11:00'!readStream: aStream	| prev | 	prev := failContinuation.	^ Continuation currentDo: [:c |		[aStream atEnd] whileFalse: [			Continuation currentDo: [:cin |				failContinuation := [										failContinuation := prev. 										cin value: #fail									].				c value: aStream next]].		^ prev value]! !!AMB methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/24/2015 11:07'!do: aBlock	| prev | 	prev := failContinuation.	^ Continuation currentDo: [:c |		Continuation currentDo: [:cin |			failContinuation := [ failContinuation := prev. 								 cin value: #fail ] .			c value: aBlock value].		^ prev value]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AMB class	instanceVariableNames: ''!!AMB class methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!assert: aBlock over: aCollection and: bCollection	^ self bagOf: [:amb | | x y |						x := amb try: aCollection.						y := amb try: bCollection.						amb assert: (aBlock value: x value: y).						{x . y}]! !!AMB class methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!assert: aBlock over: aCollection and: bCollection and: cCollection	^ self bagOf: [:amb | | x y z |						x := amb try: aCollection.						y := amb try: bCollection.						z := amb try: cCollection.						amb assert: (aBlock value: x value: y value: z).						{x . y . z}]! !!AMB class methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!bagOf: aBlock limitedTo: aNumber	| coll amb |	coll := OrderedCollection new.	amb := self new.	[		coll add: (aBlock value: amb).		[coll size < aNumber] whileTrue: [coll add: amb next]	]	on: Error do: [^ coll].	^ coll! !!AMB class methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!bagOf: aBlock	| coll amb |	coll := OrderedCollection new.	amb := self new.	[		coll add: (aBlock value: amb).		[coll add: amb next] repeat 	]	on: Error do: [^ coll]! !!AMB class methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!assert: aBlock over: aCollection	^ self bagOf: [:amb | | x |						x := amb try: aCollection.						amb assert: (aBlock value: x).						x]! !Object subclass: #AMB2	instanceVariableNames: 'continuationQueue'	classVariableNames: ''	poolDictionaries: ''	category: 'AMB'!!AMB2 commentStamp: 'jjddpp 11/28/2015 06:44' prior: 0!An AMB2 is xxxxxxxxx.!!AMB2 methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/30/2015 13:10'!repeat: aBlock	| prev | 	prev := continuationQueue removeFirst.	^ Continuation currentDo: [:c |		[ Continuation currentDo: [:cin |				continuationQueue addLast: [ cin value: #fail ].				c value: aBlock value]] repeat ]! !!AMB2 methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/30/2015 13:08'!iterate: aBlock from: seed	| prev g | 	prev := continuationQueue removeFirst.	g := seed.	^ Continuation currentDo: [:c |		[ Continuation currentDo: [:cin |				continuationQueue addLast: [ cin value: #fail ].				c value: (g := aBlock value: g)]] repeat ]! !!AMB2 methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 08:49'!do: aBlock or: bBlock	| prev | 	prev := continuationQueue removeFirst.	^ Continuation currentDo: [:c |		Continuation currentDo: [:cin |			continuationQueue addLast: [ cin value: #fail ].			c value: aBlock value].		Continuation currentDo: [:cin |			continuationQueue addLast: [ cin value: #fail ].			c value: bBlock value].		^ prev value]! !!AMB2 methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/30/2015 13:09'!readStream: aStream	| prev | 	prev := continuationQueue removeFirst.	^ Continuation currentDo: [:c |		[aStream atEnd] whileFalse: [			Continuation currentDo: [:cin |				continuationQueue addLast: [ cin value: #fail ].				c value: aStream next]].		^ prev value]! !!AMB2 methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/30/2015 13:07'!do: aBlock	| prev | 	prev := continuationQueue removeFirst.	^ Continuation currentDo: [:c |		Continuation currentDo: [:cin |			continuationQueue addLast: [ cin value: #fail ] .			c value: aBlock value].		^ prev value]! !!AMB2 methodsFor: 'core' stamp: 'jjddpp 11/28/2015 07:05'!initialize	continuationQueue := OrderedCollection with: [AMBError new signal: 'AMB tree exhausted'].! !!AMB2 methodsFor: 'core' stamp: 'jjddpp 11/28/2015 06:44'!next	^ self try: #()! !!AMB2 methodsFor: 'core' stamp: 'jjddpp 11/28/2015 07:04'!try: aCollection	| prev | 	prev := continuationQueue removeFirst.	^ Continuation callcc: [:c | 		aCollection do: [:alt | 			Continuation callcc: [:calt | 				continuationQueue addLast:  [ calt value: #fail ].				c value: alt]].	     ^ prev value]! !!AMB2 methodsFor: 'simple' stamp: 'jjddpp 11/28/2015 06:44'!boolean	^ self try: {true . false}! !!AMB2 methodsFor: 'simple' stamp: 'jjddpp 11/28/2015 06:44'!falseOrtrue	^ self try: {false . true}! !!AMB2 methodsFor: 'simple' stamp: 'jjddpp 11/28/2015 06:44'!deny: aBoolean	aBoolean ifTrue: [self next]! !!AMB2 methodsFor: 'simple' stamp: 'jjddpp 11/28/2015 06:44'!trueOrFalse	^ self try: {true . false}! !!AMB2 methodsFor: 'simple' stamp: 'jjddpp 11/28/2015 06:44'!assert: aBoolean	aBoolean ifFalse: [self next]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AMB2 class	instanceVariableNames: ''!!AMB2 class methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 06:44'!assert: aBlock over: aCollection and: bCollection	^ self bagOf: [:amb | | x y |						x := amb try: aCollection.						y := amb try: bCollection.						amb assert: (aBlock value: x value: y).						{x . y}]! !!AMB2 class methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 06:44'!assert: aBlock over: aCollection and: bCollection and: cCollection	^ self bagOf: [:amb | | x y z |						x := amb try: aCollection.						y := amb try: bCollection.						z := amb try: cCollection.						amb assert: (aBlock value: x value: y value: z).						{x . y . z}]! !!AMB2 class methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 06:44'!bagOf: aBlock limitedTo: aNumber	| coll amb |	coll := OrderedCollection new.	amb := self new.	[		coll add: (aBlock value: amb).		[coll size < aNumber] whileTrue: [coll add: amb next]	]	on: Error do: [^ coll].	^ coll! !!AMB2 class methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 06:44'!bagOf: aBlock	| coll amb |	coll := OrderedCollection new.	amb := self new.	[		coll add: (aBlock value: amb).		[coll add: amb next] repeat 	]	on: Error do: [^ coll]! !!AMB2 class methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 06:44'!assert: aBlock over: aCollection	^ self bagOf: [:amb | | x |						x := amb try: aCollection.						amb assert: (aBlock value: x).						x]! !TestCase subclass: #AMB2Test	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AMB'!!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 08:52'!testBasics4	self assert: (AMB2 bagOf: [:amb | 		| x y |		x := amb try: #(1 2 3 4 7 9).		y := amb try: #(5 4 3 14).		amb assert: (x * 2) = y.		{x . y}])	asArray = #((2 4) (7 14))		! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 08:52'!testBasics2	| amb x |	amb := AMB2 new.	x := amb try: #(1 2 3 4).	(x * 2) = 6 ifFalse: [amb next].	self assert: x = 3.	! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/30/2015 20:15'!testSendMoreMoney	"9567 + 1085 = 10652"	| amb m n o r s y e d 	send more money |	amb := AMB2 new.	m := 1.	n := amb try: ((0 to: 9) copyWithout: m).	o := amb try: ((0 to: 9) copyWithoutAll: {m . n}).	r := amb try: ((0 to: 9) copyWithoutAll: {m . n . o}).	s := amb try: ((1 to: 9) copyWithoutAll: {m . n . o . r}).	y := amb try: ((0 to: 9) copyWithoutAll: {m . n . o . r . s}).	e := amb try: ((0 to: 9) copyWithoutAll: {m . n . o . r . s . y}).	d := amb try: ((0 to: 9) copyWithoutAll: {m . n . o . r . s . y . e}).	amb assert: (d+e = y) | (d+e = (y+10)).	amb assert: (s+m+1 >= 10).	send := (s*1000) + (e*100) + (n*10) + d.	more := (m*1000) + (o*100) + (r*10) + e.	money := (m*10000) + (o*1000) + (n*100) + (e*10) + y.	amb assert: (send+more) = money.	self assert: {m . n . o . r . s . y . e . d} = #(1 6 0 8 9 2 5 7)! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/30/2015 20:15'!testAssertOverADomain	| comb |	comb := AMB2 assert: [:x | x *x = 1] over: #(1 2 3 -1 -2).	self assert: comb asArray = #(1 -1)! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 08:52'!testBasics5	| n amb |	amb := AMB2 new.	n := amb repeat: [1000 atRandom].	amb assert: n = 678.	self assert: n = 678		! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 08:52'!testBasics3	| amb x y |	amb := AMB2 new.	x := amb try: #(1 2 3 4).	y := amb try: #(5 4 3 8).	(x * 2) = y ifFalse: [amb next].	self assert: x = 2.	self assert: y = 4.	"how can we test here for the next pair of values ?"		! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/30/2015 20:14'!testAssertOver3Domains	| comb |	comb := AMB2 assert: [:string :n :char | (string occurrencesOf: char) = n]		over: #('maman' 'barbapapa' 'guiliguili' 'arthur' 'chtulu')		and: #(2 4 1)		and: #($m $b $a $i $u).	self assert: (comb asArray = #(('maman' 2 $m) ('maman' 2 $a) ('barbapapa' 2 $b) ('barbapapa' 4 $a) ('guiliguili' 2 $u) ('guiliguili' 4 $i) ('arthur' 1 $a) ('arthur' 1 $u) ('chtulu' 2 $u)))! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 08:52'!testBasics	| amb x |	amb := AMB2 new.	x := amb try: #(1 2 3).	self assert: x = 1.	"how can we test here for the next values ? tricky because of the continuation"! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/28/2015 08:51'!defaultTimeout	^ 600! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/30/2015 20:14'!testAssertOver2Domains	| comb |	comb := AMB2 assert: [:x :y | (x * 2) = y] 				over: #(1 2 3 4 7 9) and: #(5 4 3 14). 	self assert: comb asArray = #((2 4) (7 14))! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/30/2015 20:15'!testBasics7	| pairs |	pairs := AMB2 bagOf: 	[:amb | 		| c1 c2 used |		used := Set new.		c1 := amb readStream: (ReadStream on: 'ayeya').		c2 := amb readStream: (ReadStream on: 'youaye').		amb deny: (used includes: {c1 . c2}). 		amb assert: c1 ~~ c2.		used add: {c1 . c2}	] .  	self assert: pairs asArray = #(($a $y) ($a $o) ($a $u) ($a $e) ($y $o) ($y $u) ($y $a) ($y $e) ($e $y) ($e $o) ($e $u) ($e $a))! !!AMB2Test methodsFor: 'as yet unclassified' stamp: 'jjddpp 11/30/2015 20:15'!testBasics6	| pairs |	pairs := AMB2 bagOf: 	[:amb | 		| r2 |		r2 := amb repeat: [{100 atRandom . 100 atRandom}].		amb assert: r2 sum = 150.		r2	] limitedTo: 10 .	self assert: pairs size = 10.	self assert: (pairs allSatisfy: [:p | p sum = 150])! !Error subclass: #AMBError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AMB'!!AMBError commentStamp: 'spfa 11/25/2008 17:48' prior: 0!Signals the exhaustion of the search tree!TestCase subclass: #AMBTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AMB'!!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!testBasics4	self assert: (AMB bagOf: [:amb | 		| x y |		x := amb try: #(1 2 3 4 7 9).		y := amb try: #(5 4 3 14).		amb assert: (x * 2) = y.		{x . y}])	asArray = #((2 4) (7 14))		! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!testBasics2	| amb x |	amb := AMB new.	x := amb try: #(1 2 3 4).	(x * 2) = 6 ifFalse: [amb next].	self assert: x = 3.	! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!testSendMoreMoney	"9567 + 1085 = 10652"	| amb m n o r s y e d 	send more money |	amb := AMB new.	m := 1.	n := amb try: ((0 to: 9) copyWithout: m).	o := amb try: ((0 to: 9) copyWithoutAll: {m . n}).	r := amb try: ((0 to: 9) copyWithoutAll: {m . n . o}).	s := amb try: ((1 to: 9) copyWithoutAll: {m . n . o . r}).	y := amb try: ((0 to: 9) copyWithoutAll: {m . n . o . r . s}).	e := amb try: ((0 to: 9) copyWithoutAll: {m . n . o . r . s . y}).	d := amb try: ((0 to: 9) copyWithoutAll: {m . n . o . r . s . y . e}).	amb assert: (d+e = y) | (d+e = (y+10)).	amb assert: (s+m+1 >= 10).	send := (s*1000) + (e*100) + (n*10) + d.	more := (m*1000) + (o*100) + (r*10) + e.	money := (m*10000) + (o*1000) + (n*100) + (e*10) + y.	amb assert: (send+more) = money.	self assert: {m . n . o . r . s . y . e . d} = #(1 6 0 8 9 2 5 7)! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 7/20/2015 18:57'!testAssertOverADomain	| comb |	comb := AMB assert: [:x | x *x = 1] over: #(1 2 3 -1 -2).	self assert: comb asArray = #(1 -1)! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!testBasics5	| n amb |	amb := AMB new.	n := amb repeat: [1000 atRandom].	amb assert: n = 678.	self assert: n = 678		! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!testBasics3	| amb x y |	amb := AMB new.	x := amb try: #(1 2 3 4).	y := amb try: #(5 4 3 8).	(x * 2) = y ifFalse: [amb next].	self assert: x = 2.	self assert: y = 4.	"how can we test here for the next pair of values ?"		! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 7/20/2015 18:57'!testAssertOver3Domains	| comb |	comb := AMB assert: [:string :n :char | (string occurrencesOf: char) = n]		over: #('maman' 'barbapapa' 'guiliguili' 'arthur' 'chtulu')		and: #(2 4 1)		and: #($m $b $a $i $u).	self assert: (comb asArray = #(('maman' 2 $m) ('maman' 2 $a) ('barbapapa' 2 $b) ('barbapapa' 4 $a) ('guiliguili' 2 $u) ('guiliguili' 4 $i) ('arthur' 1 $a) ('arthur' 1 $u) ('chtulu' 2 $u)))! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!testBasics	| amb x |	amb := AMB new.	x := amb try: #(1 2 3).	self assert: x = 1.	"how can we test here for the next values ? tricky because of the continuation"! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 9/1/2010 23:38'!defaultTimeout	^ 600! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!testAssertOver2Domains	| comb |	comb := AMB assert: [:x :y | (x * 2) = y] 				over: #(1 2 3 4 7 9) and: #(5 4 3 14). 	self assert: comb asArray = #((2 4) (7 14))! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!testBasics7	| pairs |	pairs := AMB bagOf: 	[:amb | 		| c1 c2 used |		used := Set new.		c1 := amb readStream: (ReadStream on: 'ayeya').		c2 := amb readStream: (ReadStream on: 'youaye').		amb deny: (used includes: {c1 . c2}). 		amb assert: c1 ~~ c2.		used add: {c1 . c2}	] .  	self assert: pairs asArray = #(($a $y) ($a $o) ($a $u) ($a $e) ($y $o) ($y $u) ($y $a) ($y $e) ($e $y) ($e $o) ($e $u) ($e $a))! !!AMBTest methodsFor: 'as yet unclassified' stamp: 'spfa 11/18/2009 18:07'!testBasics6	| pairs |	pairs := AMB bagOf: 	[:amb | 		| r2 |		r2 := amb repeat: [{100 atRandom . 100 atRandom}].		amb assert: r2 sum = 150.		r2	] limitedTo: 10 .	self assert: pairs size = 10.	self assert: (pairs allSatisfy: [:p | p sum = 150])! !